package imperialferretcoders.minecraft.based.blocks

import net.minecraft.creativetab.CreativeTabs
import net.minecraft.block.Block
import cpw.mods.fml.relauncher.{Side, SideOnly}
import net.minecraft.client.renderer.texture.IIconRegister
import net.minecraft.util.IIcon
import net.minecraft.world.World
import net.minecraft.entity.player.EntityPlayer
import net.minecraft.block.material.Material
import java.util.Random
import cpw.mods.fml.common.registry.GameRegistry
import scala.collection.mutable.MutableList
import imperialferretcoders.minecraft.based.BASED

/**
 * Block for the cute little kernel's that build the various structures.
 */
class BlockKernel extends Block(Material.plants) {
  setBlockName("kernel")
  setCreativeTab(CreativeTabs.tabMisc)
  setHardness(10.0F)
  setStepSound(Block.soundTypeGrass)
  setTickRandomly(true)

  var firstStageIcon: IIcon = null
  var secondStageIcon: IIcon = null

  // Get the icon for the relevant growth state
  @SideOnly(Side.CLIENT)
  override def getIcon(side: Int, meta: Int): IIcon = {
    if (meta == 0) firstStageIcon else secondStageIcon
  }

  // Register the two kernel textures
  @SideOnly(Side.CLIENT)
  override def registerBlockIcons(iconRegister: IIconRegister): Unit = {
    firstStageIcon = iconRegister.registerIcon("based:kernel_seed")
    secondStageIcon = iconRegister.registerIcon("based:kernel_grown")
    this.blockIcon = firstStageIcon
  }

  // Overide the render type with one used for cobwebs, saplings, mushrooms, etc. Gives the kernel a 3D (non blocky) appearance
  override def isOpaqueCube: Boolean = { return false }
  override def renderAsNormalBlock: Boolean = { return false }
  override def getRenderType(): Int = { return 1 }

  // Right click activates the kernel, increasing it's size and causing it to send tendrils out in predifined directions
  override def onBlockActivated(world: World, x: Int, y: Int, z: Int, entity: EntityPlayer, t: Int, i: Float, j: Float, k: Float): Boolean = {
    val meta = world.getBlockMetadata(x, y, z)

    // Check the meta value so we only grow the block when it isn't grown
    if (meta == 0) {
      // 2 => notify the client of this change
      world.setBlockMetadataWithNotify(x, y, z, 1, 2)
    }
    // otherwise do a manual update to the structure
    else {
      updateStructure(world, x, y, z)
    }

    // Catch right clicks
    return true
  }

  // Update kernel/structure growth
  override def updateTick(world: World, x: Int, y: Int, z: Int, random: Random): Unit = {
    super.updateTick(world, x, y, z, random)

    val meta = world.getBlockMetadata(x, y, z)

    // Only grow from a grown kernel, and only once!
    if (meta == 1) {
      world.setBlockMetadataWithNotify(x, y, z, 2, 2)

      updateStructure(world, x, y, z)
    }
  }

  // Update the structure generated by this kernel
  // todo: abstract this method
  def updateStructure(world: World, x: Int, y: Int, z: Int): Unit = {
    // Grab the blocks types we need for this kernel
    val blockAir = GameRegistry.findBlock("minecraft", "air")
    val blockBorder = GameRegistry.findBlock("minecraft", "log")
    val blockTorch = GameRegistry.findBlock("minecraft", "torch")

    // Generate block data for this kernel, currently every kernel produces a 3x3 lit tunnel, surrounded with logs
    val blocks: MutableList[Tuple3[Tuple3[Int, Int, Int], Block, Int]] = new MutableList()
    for (i <- 1 to 29) {
      // Generate the borders, this is done first, because the border blocks need to be updated before torches are placed
      for (j <- -2 to 2) {
        for (k <- -2 to 2) {
          if (k == 2 || k == -2 || j == 2 || j == -2) {
            blocks += (((x + i, y + j, z + k), blockBorder, 0))
          }
        }
      }

      for (j <- -1 to 1) {
        for (k <- -1 to 1) {
          // Default to replacing the block with air
          var newBlockType = blockAir
          var meta = 0

          // Generate torches
          if (j == 0 && (k == 1 || k == -1) && (i % 4 == 3)) {
            newBlockType = blockTorch
          }

          // Add the block for updating
          blocks += (((x + i, y + j, z + k), newBlockType, meta))
        }
      }
    }

    // Generate an end to the tunnel
    for (j <- -2 to 2) {
      for (k <- -2 to 2) {
        blocks += (((x + 30, y + j, z + k), blockBorder, 0))
      }
    }

    // Update the blocks
    for (((x, y, z), blockType, meta) <- blocks) {
      // 2 =>  send block update to clients
      world.setBlock(x, y, z, blockType, meta, 2)
    }
  }

}
